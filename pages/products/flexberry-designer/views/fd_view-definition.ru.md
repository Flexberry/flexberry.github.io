---
title: Представления (View)
sidebar: flexberry-designer_sidebar
keywords: Flexberry Desinger, представления, View, атрибуты, мастер, детейл, наследование, пример
summary: Назначение представлений и особенности работы с ними
toc: true
permalink: ru/fd_view-definition.html
lang: ru
---
## Определение представления

`Представление (ракурс)` описывает некоторую логическую совокупность:
* собственных [атрибутов класса](fo_attributes-class-data.html),
* [мастеров](fd_key-concepts.html) любой вложенности и их атрибутов,
* представлений [детейлов](fd_key-concepts.html).

Представление является средством разработчика, позволяющим обеспечить отражение некоторого множества атрибутов связанных ассоциациями классов.

Для того чтобы правильно понять, что такое представление, можно представить исписанный лист бумаги и другой чистый лист бумаги с прямоугольными прорезями. Наложение второго листа на первый позволит видеть через прорези только некоторые слова или даже буквы. В этом примере: исписанный лист — объект данных, лист с прорезями — представление, наложенные листы — объект данных в представлении.

## Назначение представлений

Практическая ценность представлений очевидна: почти всегда происходит манипулирование довольно ограниченным набором свойств. Таким образом, во многих операциях (например, при чтении объекта) удобно ограничить набор свойств, вместо обработки всех, что позволит существенно увеличить производительность.

Представление используется как для формирования форм пользовательского интерфейса, так и для реализации операций (например, чтение объектов данных по представлению).

Представление является средством разработчика, позволяющим обеспечить отражение некоторого множества атрибутов, связанных ассоциациями классов.

`Обратите внимание!` Нельзя в одно представление дважды добавлять одно и то же свойство (атрибут), так как [сервис данных](fo_data-service.html) не сможет обработать данную ситуацию. Если же возникает необходимость в повторном использовании свойства, следует использовать [вычислимые поля](fo_not-stored-attributes.html).

## [Виды представлений](fd_view-types.html)

Существуют разные виды представлений. Подробнее о них можно узнать из статьи [fd_View-types|Основные виды представлений): 
* [E-представление](fd_e-view.html)
* [L-представление](fd_l-view.html)
* [T-представление](fd_t-view.html)
* [D-представление](fd_d-view.html)

### Наследование представлений

Объявленные статически представления [наследуются](fo_inheritance.html) (`наследуемые представления`), т.е. представления, объявленные для предков, действительны для потомков, более того, работа для любого объекта потомка через класс (тип) предка обеспечивается полиморфно для потомков (например, если есть список для некоторого класса, то все объекты потомков этого класса могут быть отображены в этом же списке, в этом же представлении). Статически объявленные для предков представления могут быть полностью `переопределены` в наследниках. 

В связи с наследованием представлений:
* Особым образом настраивается [чтение принадлежащих различным классам объектов в одном представлении](fo_reading-several-types-objects.html)
* Реализованы [адаптивные представления](fo_adaptive-views-for-details.html).

### Задание представлений

Представление может быть задано:
* статически (приписано метаданными-атрибутами к классам данных)
* динамически (конструироваться в исходном коде).

Представления приписываются классам данных и именуются.

### Статически заданные представления

Статически, представление определяется следующими атрибутами:

* `ViewAttribute` — объявляет представление для класса. Указывается имя представления и состав собственных и мастеровых свойств произвольного уровня. Формат указания: 

```
[(Имя св-ва мастера).(Имя св-ва мастера мастера).(Имя св-ва мастера мастера мастера ...).)(Имя атрибута) [as (пользовательское имя атрибута)) [on (путь расположения на форме))
```

* `AssociatedDetailViewAttribute` — указывает для представления [класса-шапки](fd_key-concepts.html) представление детейла, поскольку представление [шапки](fd_key-concepts.html) включает в себя представление детейла. Здесь же можно указать:
	* Должны ли детейлы прочитываться сервисами данных вместе с загрузкой [шапки](fd_key-concepts.html);
	* Путь расположения на форме;
	* Заголовок на форме;
	* Видимость на форме;
	* Имена агрегирующих функций, доступных пользователю из данного представления;
	* Должно ли представление быть [адаптивным (UseAdaptiveViewsLoading)](fo_adaptive-views-for-details.html).

* `MasterViewDefineAttribute` — дополнительно настраивает мастера в представлении [шапки](fd_key-concepts.html), можно указать:
	* Тип выбора (lookup type) мастерового объекта;
	* Строку для инициализации объекта (контрола) выбора мастерового объекта;
	* Отображаемое свойство при типе выбора LookupTypeEnum.Combo.

Путь расположения на форме указывается строкой вида:

```
[-|)[Имя)[\ [-|)[Имя))…
```

где:
* `-` означает группировку (`GroupBox`),
* `|` - закладку (Tab) на формах редактирования,
* `\` — разделитель пути. 
* `Имя` — имя соответствующей закладки/группы.

В качестве имён свойств можно указывать "звездочку", что будет означать, что необходимо использовать все свойства. Например, если просто указать "звездочку", то в представление автоматически попадают все собственные свойства, если указать `Master.*`, то это будет означать, что в представление попадают все свойства указанного мастера. Программист может отключить автоматическое попадание какого-либо свойства в представление указанием перед свойством атрибута `DisableAutoViewing`.

[Пример](https://github.com/Flexberry/FlexberryORM-DemoApp/blob/master/FlexberryORM/CDLIB/Objects/CDDA.cs) статически определённых представлений:

```
[View("Generator", new string[) { "Company on \‘|Common\-Copyright\’", "Product on \’|Common\-Copyright\’", "Copyright on \’|Common\-Copyright\’ ", "Version" } ) )
[AssociatedDetailView( "Generator", "Classes", "Generator", true, "", "", true, new string[) { } )) 
[AssociatedDetailView( "Generator", "Inheritances", "Generator", true, "", "", true, new string[) { } )) 
[View( "Edit", new string[) { "Company", "Product", "Copyright", "Version", "DataObjectNameSpace" } ) )
public class Stage:STORMCASE.Repository.Stage
{
	…
}
```

В `RunTime` представления являются экземплярами класса `ICSSoft.STORMNET.View`. Разработчик может получить проинициализированный экземпляр класса, соответствующий статически определённому представлению, вызовом метода [Information](fo_information-class-as-metadata-supervisor.html).GetView, либо через [специальные статические свойства](fo_static-view-accessors.html).

### Динамически заданные представления

Для того, чтобы динамически определить представление, необходимо конструировать экземпляр класса `View` ([пример](https://github.com/Flexberry/FlexberryORM-DemoApp/blob/master/FlexberryORM/CDLIB/CDADMTEST/Form1.cs|)). Это можно сделать четырьмя способами:
* Конструировать пустое представление, затем пользоваться методами `DefineClassType, AddDetailInView, AddMasterInView, AddProperty` для дальнейшего определения.
* Конструировать представление с указанием экземпляра класса `ViewAttribute` (он же атрибут, служащий для задания статических представлений).
* Конструировать представление по проинициализированным свойствам (загруженные + отличные от [внутренней копии данных](fo_data-object-copy.html)) объекта данных.
* Конструировать представление `по-умолчанию` (попадают только собственные свойства, а также детейловые свойства, что указывается соответствующим параметром) 

Также, через методы класса `View` можно полностью получить структуру представления, а также изменить её (получить/добавить/удалить элементы, входящие в представление).

Стоит также отметить, что настоятельно рекомендуется определять имя для динамически создаваемых представлений.

{% include note.html content="Кеширование View на форме для разных вычиток может приводить к ошибкам, поскольку при чтении с наложением ограничения конкретная инстанция View может быть изменена [сервисом данных](fo_data-service.html)." %}

## Дополнительные сведения о представлениях

* Во [Flexberry ORM](fo_flexberry-orm.html) существуют [стандартные операции](fo_view-operations.html), позволяющие найти для нескольких классов их общего предка и общие представления. Также можно манипулировать с представлениями, как с множествами: вычислить, например, объединение или разность представлений.
* Существуют [рекомендации по добавлению мастеров в представления](fd_masters-in-view.html).
* Существует [способ проверить, удовлетворяет ли некоторый объект представлению](fo_test-object-for-viewing.html).
* [ViewPropertyAppender](fo_view-property-appender.html) - класс, который позволяет расширять представление свойствами, которые находятся в [ограничении](fo_limit-function.html)
