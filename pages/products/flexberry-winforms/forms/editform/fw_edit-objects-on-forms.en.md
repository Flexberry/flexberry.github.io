---
title: Editing data objects on forms
sidebar: flexberry-winforms_sidebar
keywords: Flexberry Winforms, forms, controls, data objects
summary: Toggle editable objects, manually creating forms, editing, updating, and performance interaction while editing a feature
toc: true
permalink: en/fw_edit-objects-on-forms.html
lang: en
autotranslated: true
hash: 96e5222bc0cc4ab8418573b18bd3b8a5f541540ad3f2486cb0687dcf4737419f
---

Edit the data objects on the forms has a lot of nuances and possibilities. The most common outlined in this article.

## Switching the editable object without closing the edit form

Sometimes the script system involves a sequence viewable or editable objects on the edit form without closing the form. An analogue of this functionality is to view events in the Windows EventLog (EventLog). Flexberry Platform for the organization of this script supports a special feature that is available from independent edit forms: `SwitchEditingObject(newObject)`.
Typical and recommended implementation from the application project can be done in the following way:

* A dependent includes an interface portion for switching the objects (meaning the user interface: buttons and other controls).

* The dependent form contains events that are generated by the interface part (go forward, backward, on the specified object, etc.). The triggering of these events is linked to the corresponding controls. Example:

```csharp
/// <summary> 
/// Delegate for event rewind objects 
/// </summary> 
/// <param name="sender"></param> 
/// <param name="e"></param> 
public delegate void PrevNextEventArgsHandler(object sender, EventArgs e);

//... 
// *** Start programmer edit section *** (WinformПланетаE CustomMembers) 
///<summary> 
/// Forward 
///</summary> 
public event PrevNextEventArgsHandler NextEvent;
/// <summary> 
/// Rewind 
/// </summary> 
public event PrevNextEventArgsHandler PrevEvent;

private void button1_Click(object sender, EventArgs e)
{
    if (NextEvent != null)
    {
        NextEvent(this, e);
    }
}

private void button2_Click(object sender, EventArgs e)
{
    if (PrevEvent != null)
    {
        PrevEvent(this, e);
    }
}

// *** End programmer edit section *** (WinformПланетаE CustomMembers) 
```

* Independent form sees these events, but through the interface (after the code class independent Flexberry generates an interface to define event methods and attributes dependent form)

```csharp
/// <summary> 
/// this interface definition, which is inherited by the dependent form, but it is in the file independent 
/// </summary> 
public interface DPDIПланетаE
{

    // *** Start programmer edit section *** (DPDIПланетаE Members) 
    ///<summary> 
    /// Forward 
    ///</summary> 
    event PrevNextEventArgsHandler NextEvent;
    /// <summary> 
    /// Rewind 
    /// </summary> 
    event PrevNextEventArgsHandler PrevEvent;

    // *** End programmer edit section *** (DPDIПланетаE Members) 

}
```

* Independent form subscribes to these additional events dependent forms in a special method `prv_AttachEventsFromDpdForm(object form)`

```csharp
protected virtual void prv_AttachEventsFromDpdForm(object form)
{
    // *** Start programmer edit section *** (prv_AttachEventsFromDpdForm( object form )) 
    IIS.AlteredHierarchy.DPDIПланетаE form1 = ((IIS.AlteredHierarchy.DPDIПланетаE)(form));
    form1.NextEvent -= new PrevNextEventArgsHandler(form1_NextEvent);
    form1.NextEvent += new PrevNextEventArgsHandler(form1_NextEvent);

    form1.PrevEvent -= new PrevNextEventArgsHandler(form1_PrevEvent);
    form1.PrevEvent += new PrevNextEventArgsHandler(form1_PrevEvent);

    // *** End programmer edit section *** (prv_AttachEventsFromDpdForm( object form )) 
    IIS.AlteredHierarchy.DPDIПланетаE typedForm = ((IIS.AlteredHierarchy.DPDIПланетаE)(form));
}

//... 
// *** Start programmer edit section *** (Planete CustomMembers) 
void form1_PrevEvent(object sender, EventArgs e)
{
    GetNextOrPrevObj(false);
}

void form1_NextEvent(object sender, EventArgs e)
{
    GetNextOrPrevObj(true);
}

/// <summary> 
/// An example of a method that gets the previous or next object and changes the object that we are editing 
/// </summary> 
/// <param name="next"></param> 
private void GetNextOrPrevObj(bool next)
{
    KeyGuid pk = (KeyGuid)((BaseWinEdit)Editor).DataObject.__PrimaryKey;
    IDataService ds = DataServiceProvider.DataService;

    LoadingCustomizationStruct lcs = LoadingCustomizationStruct.GetSimpleStruct(typeof(Планета), "Planetae");
    lcs.ColumnsSort = new[] { new ColumnsSortDef("primaryKey", SortOrder.Asc) };
    lcs.ReturnTop = 1;    
    Function f = next ? FunctionBuilder.BuildGreater(pk) : FunctionBuilder.BuildLess(pk);     
    lcs.LimitFunction = f;
    DataObject[] dataObjects = ds.LoadObjects(lcs);
    if (dataObjects.Length > 0)
    {
        DataObject dataObject = dataObjects[0];
        //dataObject.LockObject("AnyKey"); Uncomment if the view in read-only mode 

        SwitchEditingObject(dataObject);
    }
}
// *** End programmer edit section *** (Planete CustomMembers) 
```

When you switch object logic works, the same logic close a form relevant to the request for saving a modified object, clearing the lock. Then everything works the same as the opening: checked lock, is installed or is proposed to open in read-only mode. If the user refuses to open a locked object read-only, then form tries to open the previous object completely by running logic on opening (in a method `PrepareDataObjectForEdit(ICSSoft.STORMNET.DataObject dobject)` happens zachitka object, if this logic is not overridden).

## Update the local copy of the object form

When the form is opened for editing, it creates a local copy of the object. The issue of conservation is set when the difference between this local copy and the edited data object.

There are situations when the object in the database has changed while editing a shape, i.e. a local copy of the form is outdated. In this situation, you should update your local copy of the form by calling the method `ResetDataObjectCopy` independent form. As a parameter of the method is passed the object that will now be a local copy of the form.

## Create edit form object

There are several ways to "manually" create the edit form of the object with the ability to associate it with the properties of an existing data object. They are described in detail in article [Manager edit](fw_editmanager.html).

## Work on the editing form with fields for multiple objects

Sometimes faced with the task to organize the work with fields of objects of different classes on one form of editing. For example, the necessary form for a fast input where some fields belongs to one class, part of another, etc. In this case, it is necessary to monitor the preservation of this "complex presentation".

One of the variants of solving this task can be usage of several [EditManager](fw_editmanager.html).

For this you need to create objects and tie them `EditManager`.

The logic of preservation of objects from the "complex representation" depends on the specific task (e.g., what fields to determine that the same object is already in the database how to interpret the change of the stored object, etc.). While maintaining the "complex representation" is necessary to pay attention to the points made in the article:

* [Processing of a set of objects (including different types)](fo_processing-multiple-objects.html)
* [Update related objects](fo_update-related-objects.html)

## Performance interaction when editing features

Basically, the interactions are by call the edit form from the form list (for example, when you open the object for editing), and Vice versa, with the edit form for the list form (for example, to select the associated object). Anyway, the point is that from one form to another is sent to object data and edit it in whole or in part. Accordingly, in a specific (relative) metforminom the interaction of the one form acts as a __initiator__ editing, and the second as __editor__.

* If an object is opened from the list on the edit form of the list is the initiator, and the edit form editor. In this case, obviously the object is passed to the edit in the edit form.
* If editor to select a related object (craftsman) opens the list form, the edit form is the initiator, and the form list editor.

The difference between cases 1 and 2 only in the fact that in case 2, the object is not edited as a whole, but only part of it.

## Useful links

* [Reads belonging to different object classes in a single view](fo_reading-several-types-objects.html)
* [Uniform field](fw_editform.html)



